-- Echo server program
module Main where

import Control.Monad (unless,when)
import Network.Socket hiding (recv)
import qualified Data.ByteString as S
import Data.Word(Word8)
import Control.Concurrent(threadDelay)
import Data.List(isPrefixOf)
import Network.Socket.ByteString (recv, sendAll)
import Com.DiagMessage
import Com.HSFZMessage
import Util.Encoding

main :: IO ()
main = withSocketsDo $
    do addrinfos <- getAddrInfo
                    (Just (defaultHints {addrFlags = [AI_PASSIVE]}))
                    Nothing (Just "6801")
       let serveraddr = head addrinfos
       sock <- socket (addrFamily serveraddr) Stream defaultProtocol
       bindSocket sock (addrAddress serveraddr)
       listen sock 1
       loop sock

    where
      loop s = do
        (connSock, _) <- accept s
        talk connSock
        loop s
        -- sClose connSock
        -- sClose sock

      talk :: Socket -> IO ()
      talk connSock = do 
             putStrLn "now we are talking..."
             isCon <- sIsConnected connSock
             isBound <- sIsBound connSock
             isListening <-sIsListening connSock
             isReadable <-sIsReadable connSock
             isWritable <-sIsWritable connSock
             when isCon (putStrLn "connected!")
             when isBound (putStrLn $ "bound!")
             when isListening (putStrLn $ "listening!")
             when isReadable (putStrLn $ "readable!")
             when isWritable (putStrLn $ "writable!")
             msg <- recv connSock 1024
             print $ "trying to deserialize bytestring:" ++  (show msg)
             unless (S.null msg) $ do
              print $ "received over the wire: " ++ (showBinString msg)
              threadDelay(500*1000)
              sendAll connSock $ replyTo $ deserialize2Hsfz msg
              putStrLn "sent back response, starting to listen again..."
              talk connSock
      replyTo :: Maybe HSFZMessage -> S.ByteString
      replyTo (Just m) = msg2ByteString responseHsfz
        where dmsg = hsfz2diag m
              payload = diagPayload dmsg
              responsePayload
                | [0x22,0x20,0x00] `isPrefixOf` payload = -- readSecondaryErrorMemory 
                    [0x62,0x20,0x0,0x40,0xf,0xff,0xf,0x80,0x40,0x2,0xf,0x80,0x40,0x27,0xf,0x80,0x40,0x2b,0x4c,0x80,0x41,0x88,0xe,0x80,0x41,0xa6,0xf,0x93,0x7,0x1f,0xf]
                | [0x19,0x02,0x0f] `isPrefixOf` payload = -- readPrimaryErrorMemory 
                    [0x59,0x2,0x4f,0x3,0x0,0xc,0xf,0x3,0x0,0xd,0xf,0x3,0x0,0x8c,0xf,0x3,0x0,0x8d,0xf,0x3,0x3,0x50,0xf,0x3,0x3,0x52,0xf,0x3,0x4,0x10,0xf,0x80,0x40,0x14,0xf,0x80,0x40,0x2d,0xf,0x80,0x40,0x86,0xf,0x80,0x40,0x87,0xf,0x80,0x40,0x88,0xf,0x80,0x40,0x96,0xf,0x80,0x40,0x97,0xf,0x80,0x40,0x9a,0xf,0x80,0x40,0x9b,0xf,0x80,0x40,0x9c,0xf,0x80,0x40,0xa7,0xf,0x80,0x40,0xbd,0xe,0x80,0x40,0xf5,0xf,0x80,0x41,0x21,0xf,0x80,0x41,0x25,0xf,0x80,0x41,0x5b,0xf,0x80,0x41,0x64,0xf,0x80,0x41,0x66,0xf,0x80,0x41,0x68,0xf,0x80,0x41,0x6a,0xf,0x80,0x43,0x6e,0xf,0xd9,0xc,0x1,0xf,0xd9,0xc,0x4,0xf,0xd9,0xc,0x7,0xf,0xd9,0xc,0xa,0xf,0xd9,0xc,0xd,0xf,0xd9,0xc,0x10,0xf,0xd9,0xd,0x1,0xf,0xd9,0xd,0x7,0xf,0xd9,0xd,0xa,0xf,0xd9,0xd,0xd,0xf,0xd9,0xd,0x17,0xf,0xd9,0xd,0x29,0xf]
                | otherwise = (head payload + 0x40):(tail payload)
              response = DiagnosisMessage (diagTarget dmsg) (diagSource dmsg) responsePayload
              responseHsfz = diag2hsfz response DataBit
      replyTo _ = error "not a valid message"

